<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>对称图像生成器</title>
  <style>
    body { font-family: Inter, Roboto, Arial, sans-serif; max-width:1100px; margin:28px auto; padding: 0 16px; color:#222; }
    h1 { font-weight:700; }
    .preview { display:flex; gap:16px; align-items:flex-start; }
    .preview img { max-width:100%; height:auto; border-radius:6px; }
    .col { flex:1; }
    .row { display:flex; gap:12px; margin-top:12px; }
    .center { text-align:center; }
    label { display:block; margin-top:8px; }
    .controls { margin:12px 0; }
    .divider { height:1px; background:#f0f0f0; margin:16px 0; }
    .modal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1000; justify-content:center; align-items:center; }
    .modal.show { display:flex; }
    .modal-content { max-width:90vw; max-height:90vh; overflow:auto; background:white; padding:10px; border-radius:8px; }
    .modal-close { position:absolute; top:10px; right:20px; color:white; font-size:28px; cursor:pointer; }
    /* Upload / preview styles */
    .original-container { position:relative; overflow:auto; border-radius:8px; background:#fafafa; border:1px dashed #e0e0e0; padding:8px; max-width:100%; max-height:80vh; display:flex; align-items:center; justify-content:center; }
    .drop-instructions { position:absolute; inset:8px; display:flex; align-items:center; justify-content:center; pointer-events:none; }
    .upload-controls { position:absolute; left:16px; top:16px; display:flex; gap:8px; z-index:10; }
    .upload-label, .btn { background:#0066ff; color:white; padding:8px 12px; border-radius:6px; cursor:pointer; border:none; font-size:0.95rem; }
    .btn.secondary { background:#f3f4f6; color:#111; border:1px solid #ddd; }
    .upload-input { display:none; }
    canvas { border-radius:6px; }
  </style>
</head>
<body>
  <h1>对称图像生成器</h1>

  {% if message %}
    <div style="color:crimson">{{ message }}</div>
  {% endif %}

  <div>
    <p style="color:#666; font-size:0.95em">检测人脸后点击青色框自动选择人脸</p>
  </div>

  <div class="divider"></div>

  <!-- 原图单独显示，按原始像素比例，容器可滚动 -->
  <h2>原图（可拖动红线操作）</h2>
  <div class="original-container">
    <div class="upload-controls">
      <input id="imageInput" class="upload-input" type="file" accept="image/*">
      <button id="detectButton" class="btn" style="display:none">检测人脸</button>
    </div>
    <div class="drop-instructions"><p style="color:#666">将图片拖放到此处或点击图片上传</p></div>
    <canvas id="previewCanvas" style="display:block; max-width:100%; height:auto;"></canvas>
  </div>
  
  <!-- 隐藏元素存储人脸坐标 -->
  <div id="facesData" style="display:none;">{{ faces }}</div>

  <h2 style="margin-top:18px">实时结果</h2>
  <div class="preview">
    <div class="col center">
      <h3>左侧镜像 → 右侧</h3>
      <canvas id="leftRightCanvas" style="max-width:100%; border:1px solid #ddd; cursor:pointer;" title="双击查看大图"></canvas>
      <div style="margin-top:8px"><a id="downloadLeftRight" class="btn" href="#" style="text-decoration: none;">下载</a></div>
    </div>
    <div class="col center">
      <h3>右侧镜像 → 左侧</h3>
      <canvas id="rightLeftCanvas" style="max-width:100%; border:1px solid #ddd; cursor:pointer;" title="双击查看大图"></canvas>
      <div style="margin-top:8px"><a id="downloadRightLeft" class="btn" href="#" style="text-decoration: none;">下载</a></div>
    </div>
  </div>

  <!-- 模态框用于显示放大图像 -->
  <div id="imageModal" class="modal">
    <span class="modal-close" onclick="document.getElementById('imageModal').classList.remove('show')">&times;</span>
    <div class="modal-content" id="modalContent">
      <canvas id="modalCanvas"></canvas>
    </div>
  </div>


  {% if original_b64 %}
  <h2>生成结果</h2>
  <div class="preview">
    <div class="col">
      <h3 class="center">原图</h3>
      <img src="{{ original_b64 }}" alt="original">
      <div class="center" style="margin-top:8px"><a href="{{ original_b64 }}" download="original_with_line.png">下载</a></div>
    </div>
    <div class="col">
      <h3 class="center">左侧镜像 → 右侧</h3>
      <img src="{{ left_mirrored_b64 }}" alt="left_mirrored">
      <div class="center" style="margin-top:8px"><a href="{{ left_mirrored_b64 }}" download="left_to_right.png">下载</a></div>
    </div>
    <div class="col">
      <h3 class="center">右侧镜像 → 左侧</h3>
      <img src="{{ right_mirrored_b64 }}" alt="right_mirrored">
      <div class="center" style="margin-top:8px"><a href="{{ right_mirrored_b64 }}" download="right_to_left.png"  >下载</a></div>
    </div>
  </div>
  {% endif %}

  <script>
  (function(){
    const fileInput = document.getElementById('imageInput');
    const detectButton = document.getElementById('detectButton');
    const pasteButton = document.getElementById('pasteButton');
    const ratioRange = document.getElementById('ratio');
    const rval = document.getElementById('rval');
    const previewCanvas = document.getElementById('previewCanvas');
    const lrCanvas = document.getElementById('leftRightCanvas');
    const rlCanvas = document.getElementById('rightLeftCanvas');
    const dLR = document.getElementById('downloadLeftRight');
    const dRL = document.getElementById('downloadRightLeft');
    const pCtx = previewCanvas.getContext && previewCanvas.getContext('2d');
    const lrCtx = lrCanvas.getContext && lrCanvas.getContext('2d');
    const rlCtx = rlCanvas.getContext && rlCanvas.getContext('2d');
    let img = null;
    let previewImageData = null;
    let offLeftCanvas = null;
    let offRightCanvas = null;
    let dragging = false;
    let currentRatio = 0.5;  // track ratio without slider
    let faces = [];  // detected faces from backend
    let scheduledRender = null; // debounce handle for heavy rendering
    let uploadedFile = null;  // store uploaded file for detection

    function setCanvasSize(c, w, h){ c.width = w; c.height = h; }

    function drawAll(){
      if(!img) return;
      const ratio = currentRatio;
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;

      // set preview canvas size (use natural size; CSS will scale down if needed)
      setCanvasSize(previewCanvas, iw, ih);

      const splitX = Math.round(iw * ratio);
      const lineWidth = Math.max(2, Math.round(ih * 0.005));

      // Original with line
      pCtx.clearRect(0,0,iw,ih);
      pCtx.drawImage(img, 0,0, iw, ih);
      pCtx.beginPath(); pCtx.moveTo(splitX+0.5,0); pCtx.lineTo(splitX+0.5, ih);
      pCtx.strokeStyle='red'; pCtx.lineWidth = lineWidth; pCtx.stroke();

      // Draw face rectangles in cyan
      faces.forEach(face => {
        pCtx.beginPath();
        pCtx.rect(face.x, face.y, face.w, face.h);
        pCtx.strokeStyle = 'cyan';
        pCtx.lineWidth = Math.max(2, Math.round(ih * 0.005));
        pCtx.stroke();
      });


      // Left -> Right: create image composed of left area + flipped left area (no scaling)
      const leftW = splitX;
      const rightW = iw - splitX;
      if(leftW > 0){
        const lrW = leftW * 2;
        setCanvasSize(lrCanvas, lrW, ih);
        lrCtx.clearRect(0,0,lrW,ih);
        // use offLeftCanvas to avoid recreating unless leftW changed
        if(!offLeftCanvas || offLeftCanvas.width !== leftW){ offLeftCanvas = document.createElement('canvas'); offLeftCanvas.width = leftW; offLeftCanvas.height = ih; offLeftCanvas.getContext('2d').clearRect(0,0,leftW,ih); offLeftCanvas.getContext('2d').drawImage(img, 0,0, leftW, ih, 0,0, leftW, ih); }
        lrCtx.drawImage(offLeftCanvas, 0,0, leftW, ih, 0,0, leftW, ih);
        lrCtx.save(); lrCtx.translate(leftW * 2, 0); lrCtx.scale(-1, 1);
        lrCtx.drawImage(offLeftCanvas, 0,0, leftW, ih, 0,0, leftW, ih);
        lrCtx.restore();
        // no split line on result image
      } else {
        lrCtx.clearRect(0,0,lrCanvas.width, lrCanvas.height);
      }

      // Right -> Left: create image composed of flipped right area + right area (no scaling)
      if(rightW > 0){
        const rlW = rightW * 2;
        setCanvasSize(rlCanvas, rlW, ih);
        rlCtx.clearRect(0,0,rlW,ih);
        if(!offRightCanvas || offRightCanvas.width !== rightW){ offRightCanvas = document.createElement('canvas'); offRightCanvas.width = rightW; offRightCanvas.height = ih; offRightCanvas.getContext('2d').clearRect(0,0,rightW,ih); offRightCanvas.getContext('2d').drawImage(img, splitX,0, rightW, ih, 0,0, rightW, ih); }
        rlCtx.save(); rlCtx.translate(rightW, 0); rlCtx.scale(-1, 1);
        rlCtx.drawImage(offRightCanvas, 0,0, rightW, ih, 0,0, rightW, ih);
        rlCtx.restore();
        rlCtx.drawImage(offRightCanvas, 0,0, rightW, ih, rightW, 0, rightW, ih);
        // no split line on result image
      } else {
        rlCtx.clearRect(0,0,rlCanvas.width, rlCanvas.height);
      }

      // update download links for mirrored results
      dLR.href = lrCanvas.toDataURL('image/png'); dLR.download = 'left_to_right.png';
      dRL.href = rlCanvas.toDataURL('image/png'); dRL.download = 'right_to_left.png';
    }

    // Paste from clipboard button
    if(pasteButton){
      pasteButton.addEventListener('click', async function(){
        if(!navigator.clipboard || !navigator.clipboard.read){
          alert('当前浏览器不支持从剪贴板读取图片。');
          return;
        }
        try{
          const items = await navigator.clipboard.read();
          for(const item of items){
            for(const type of item.types){
              if(type.startsWith('image/')){
                const blob = await item.getType(type);
                let file;
                try{ file = new File([blob], 'clipboard.png', {type: blob.type}); } catch(e){ file = blob; }
                uploadedFile = file;
                detectButton.style.display = 'inline-block';
                const reader = new FileReader();
                reader.onload = function(ev){
                  const im = new Image();
                  im.onload = function(){
                    img = im;
                    faces = [];
                    document.getElementById('facesData').textContent = '[]';
                    const iw = img.naturalWidth || img.width;
                    const ih = img.naturalHeight || img.height;
                    setCanvasSize(previewCanvas, iw, ih);
                    pCtx.clearRect(0,0,iw,ih);
                    pCtx.drawImage(img, 0,0, iw, ih);
                    try { previewImageData = pCtx.getImageData(0,0,iw,ih); } catch(e) { previewImageData = null; }
                    offLeftCanvas = null; offRightCanvas = null;
                    drawAll();
                    document.querySelector('.original-container div p').style.display = 'none';
                  };
                  im.src = ev.target.result;
                };
                reader.readAsDataURL(file);
                return;
              }
            }
          }
          alert('剪贴板中未找到图片。');
        }catch(err){
          console.error('读取剪贴板失败', err);
          alert('读取剪贴板失败（可能需权限）');
        }
      });
    }

    fileInput.addEventListener('change', function(ev){
      const f = ev.target.files && ev.target.files[0];
      if(!f) return;
      uploadedFile = f;
      detectButton.style.display = 'inline-block';
      const reader = new FileReader();
      reader.onload = function(e){
          const im = new Image();
          im.onload = function(){
            img = im;
            faces = [];  // reset faces
            document.getElementById('facesData').textContent = '[]';
            // draw image once into preview and cache image data for fast overlay updates
            const iw = img.naturalWidth || img.width;
            const ih = img.naturalHeight || img.height;
            setCanvasSize(previewCanvas, iw, ih);
            pCtx.clearRect(0,0,iw,ih);
            pCtx.drawImage(img, 0,0, iw, ih);
            try { previewImageData = pCtx.getImageData(0,0,iw,ih); } catch(e) { previewImageData = null; }
            // reset offscreen caches
            offLeftCanvas = null; offRightCanvas = null;
            drawAll();
          };
          im.src = e.target.result;
      };
      reader.readAsDataURL(f);
    });

    // Drag-and-drop support: allow user to drop an image onto the preview area
    const dropArea = document.querySelector('.original-container');
    if(dropArea){
      dropArea.addEventListener('dragover', function(e){ e.preventDefault(); dropArea.style.outline = '2px dashed #bbb'; });
      dropArea.addEventListener('dragleave', function(e){ e.preventDefault(); dropArea.style.outline = ''; });
      dropArea.addEventListener('drop', function(e){
        e.preventDefault(); dropArea.style.outline = '';
        const f = (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]);
        if(!f) return;
        uploadedFile = f;
        detectButton.style.display = 'inline-block';
        const reader = new FileReader();
        reader.onload = function(ev){
          const im = new Image();
          im.onload = function(){
            img = im;
            faces = [];
            document.getElementById('facesData').textContent = '[]';
            const iw = img.naturalWidth || img.width;
            const ih = img.naturalHeight || img.height;
            setCanvasSize(previewCanvas, iw, ih);
            pCtx.clearRect(0,0,iw,ih);
            pCtx.drawImage(img, 0,0, iw, ih);
            try { previewImageData = pCtx.getImageData(0,0,iw,ih); } catch(e) { previewImageData = null; }
            offLeftCanvas = null; offRightCanvas = null;
            drawAll();
            document.querySelector('.original-container div p').style.display = 'none';
          };
          im.src = ev.target.result;
        };
        reader.readAsDataURL(f);
      });
    }
    const originalContainer = document.querySelector('.original-container');
    originalContainer.addEventListener('click', function(ev) {
      if (!img && !dragging && !ev.target.closest('.upload-controls')) {  // 避免点击控件内部触发
        fileInput.click();
        document.querySelector('.original-container p').style.display = 'none';
      }
    });
    // Detect faces button
    detectButton.addEventListener('click', async function(){
      if(!uploadedFile) return;
      detectButton.disabled = true;
      detectButton.textContent = '检测中...';
      const formData = new FormData();
      formData.append('image', uploadedFile);
      try {
        const response = await fetch('/detect_faces', {
          method: 'POST',
          body: formData
        });
        if(response.ok){
          const data = await response.json();
          faces = data.faces || [];
          console.log('检测到人脸:', faces);
          // persist faces into hidden element so boxes remain after interactions
          try{ document.getElementById('facesData').textContent = JSON.stringify(faces); }catch(e){}
          // update overlay immediately and schedule full render (debounced) to avoid UI jank
          if(img){
            if(previewImageData && pCtx){
              pCtx.putImageData(previewImageData,0,0);
              const iw = previewCanvas.width, ih = previewCanvas.height;
              const splitX = Math.round(iw * currentRatio);
              pCtx.beginPath(); pCtx.moveTo(splitX+0.5,0); pCtx.lineTo(splitX+0.5, ih);
              pCtx.strokeStyle='red'; pCtx.lineWidth = Math.max(2, Math.round(ih * 0.005));
              pCtx.stroke();
              faces.forEach(face => { pCtx.beginPath(); pCtx.rect(face.x, face.y, face.w, face.h); pCtx.strokeStyle='cyan'; pCtx.lineWidth = Math.max(2, Math.round(ih * 0.005)); pCtx.stroke(); });
            }
            if(scheduledRender) { try{ if(window.cancelIdleCallback && scheduledRender._idleId) cancelIdleCallback(scheduledRender._idleId); }catch(e){} clearTimeout(scheduledRender); scheduledRender = null; }
            if(window.requestIdleCallback){ const id = requestIdleCallback(()=>{ drawAll(); scheduledRender = null; }); scheduledRender = { _idleId: id }; }
            else { scheduledRender = setTimeout(()=>{ drawAll(); scheduledRender = null; }, 50); }
          }
        }
      } catch(err) {
        console.error('人脸检测失败:', err);
      } finally {
        detectButton.disabled = false;
        detectButton.textContent = '检测人脸';
      }
    });

    // On input, update only the preview overlay (fast). On change (release), render full results.
    // (Removed slider events; only drag-based interaction remains)

    // allow dragging the split line on previewCanvas to change ratio
    previewCanvas.addEventListener('mousedown', function(ev){ if(!img) return; dragging = true; });
    window.addEventListener('mouseup', function(ev){ if(!dragging) return; dragging = false; // finalize and render
      if(img) drawAll(); });
    previewCanvas.addEventListener('mousemove', function(ev){ if(!dragging || !img) return; // only update overlay line, do not re-render heavy canvases
      if(previewImageData && pCtx){
        pCtx.putImageData(previewImageData,0,0);
        const rect = previewCanvas.getBoundingClientRect();
        const scaleX = previewCanvas.width / rect.width;
        let x = (ev.clientX - rect.left) * scaleX;
        x = Math.max(0, Math.min(previewCanvas.width, x));
        currentRatio = x / previewCanvas.width;
        pCtx.beginPath(); pCtx.moveTo(x+0.5,0); pCtx.lineTo(x+0.5, previewCanvas.height);
        pCtx.strokeStyle='red'; pCtx.lineWidth = Math.max(2, Math.round(previewCanvas.height * 0.005));
        pCtx.stroke();
      }
    });

    // Click on face rectangle to set split line to face center
    previewCanvas.addEventListener('click', function(ev){
      if(!img || faces.length === 0) return;
      const rect = previewCanvas.getBoundingClientRect();
      const scaleX = previewCanvas.width / rect.width;
      const scaleY = previewCanvas.height / rect.height;
      const clickX = (ev.clientX - rect.left) * scaleX;
      const clickY = (ev.clientY - rect.top) * scaleY;
      // Check if click is within any face
      for (let face of faces){
        if(clickX >= face.x && clickX <= face.x + face.w && clickY >= face.y && clickY <= face.y + face.h){
          // Set split line to face center
          currentRatio = (face.x + face.w / 2) / previewCanvas.width;
          // update overlay immediately
          if(previewImageData && pCtx){
            pCtx.putImageData(previewImageData,0,0);
            const iw = previewCanvas.width, ih = previewCanvas.height;
            const splitX = Math.round(iw * currentRatio);
            pCtx.beginPath(); pCtx.moveTo(splitX+0.5,0); pCtx.lineTo(splitX+0.5, ih);
            pCtx.strokeStyle='red'; pCtx.lineWidth = Math.max(2, Math.round(ih * 0.005));
            pCtx.stroke();
            faces.forEach(f => { pCtx.beginPath(); pCtx.rect(f.x, f.y, f.w, f.h); pCtx.strokeStyle='cyan'; pCtx.lineWidth = Math.max(2, Math.round(ih * 0.005)); pCtx.stroke(); });
          }
          // schedule full render using idle callback or timeout to avoid jank
          if(scheduledRender){ try{ if(window.cancelIdleCallback && scheduledRender._idleId) cancelIdleCallback(scheduledRender._idleId); }catch(e){} clearTimeout(scheduledRender); scheduledRender = null; }
          if(window.requestIdleCallback){ const id = requestIdleCallback(()=>{ drawAll(); scheduledRender = null; }); scheduledRender = { _idleId: id }; }
          else { scheduledRender = setTimeout(()=>{ drawAll(); scheduledRender = null; }, 50); }
          break;
        }
      }
    });

    // double-click to show enlarged version
    const showModal = (sourceCanvas) => {
      const modal = document.getElementById('imageModal');
      const modalCanvas = document.getElementById('modalCanvas');
      const mCtx = modalCanvas.getContext('2d');
      modalCanvas.width = sourceCanvas.width;
      modalCanvas.height = sourceCanvas.height;
      mCtx.drawImage(sourceCanvas, 0, 0);
      modal.classList.add('show');
    };
    lrCanvas.addEventListener('dblclick', () => showModal(lrCanvas));
    rlCanvas.addEventListener('dblclick', () => showModal(rlCanvas));
    
    // close modal on Esc key
    window.addEventListener('keydown', (ev) => {
      if(ev.key === 'Escape') document.getElementById('imageModal').classList.remove('show');
    });  })();
  </script>
</body>
</html>
